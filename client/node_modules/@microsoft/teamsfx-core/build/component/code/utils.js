"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = exports.maskSecretValues = exports.convertScriptErrorToFxError = exports.executeCommand = exports.convertToLangKey = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const path = tslib_1.__importStar(require("path"));
const os_1 = tslib_1.__importDefault(require("os"));
const child_process_1 = require("child_process");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const script_1 = require("../../error/script");
function convertToLangKey(programmingLanguage) {
    switch (programmingLanguage) {
        case "javascript": {
            return "js";
        }
        case "typescript": {
            return "ts";
        }
        case "csharp": {
            return "csharp";
        }
        default: {
            return "js";
        }
    }
}
exports.convertToLangKey = convertToLangKey;
function capitalizeFirstLetter(raw) {
    return raw.charAt(0).toUpperCase() + raw.slice(1);
}
async function executeCommand(command, projectPath, logProvider, ui, workingDirectory, env, shell, timeout, redirectTo) {
    return new Promise(async (resolve, reject) => {
        var _a, _b;
        let workingDir = workingDirectory || ".";
        workingDir = path.isAbsolute(workingDir) ? workingDir : path.join(projectPath, workingDir);
        // Drive letter should be uppercase, otherwise when we run webpack in exec, it fails to resolve nested dependencies.
        if (os_1.default.platform() === "win32") {
            workingDir = capitalizeFirstLetter(path.resolve(workingDir !== null && workingDir !== void 0 ? workingDir : ""));
        }
        const defaultOsToShellMap = {
            win32: "powershell",
            darwin: "bash",
            linux: "bash",
        };
        // const shellToOsMap: any = {
        //   cmd: ["win32"],
        //   powershell: ["win32"],
        //   pwsh: ["win32"],
        //   sh: ["linux", "darwin"],
        //   bash: ["linux", "darwin"],
        // };
        let run = command;
        shell = shell !== null && shell !== void 0 ? shell : defaultOsToShellMap[process.platform];
        let appendFile = undefined;
        if (redirectTo) {
            appendFile = path.isAbsolute(redirectTo) ? redirectTo : path.join(projectPath, redirectTo);
        }
        if (shell === "cmd") {
            run = `%ComSpec% /D /E:ON /V:OFF /S /C "CALL ${command}"`;
        }
        // if (!shell) {
        //   await logProvider.warning(
        //     `Failed to run command: "${command}" on path: "${workingDir}", shell type unspecified`
        //   );
        //   resolve(ok(["", {}]));
        //   return;
        // }
        // const osList = shellToOsMap[shell];
        // if (!osList.includes(os.platform())) {
        //   await logProvider.warning(
        //     `Failed to run command: "${command}" on path: "${workingDir}", shell ${shell} can not be executed in os ${os}`
        //   );
        //   resolve(ok(["", {}]));
        //   return;
        // }
        await logProvider.info(`Start to run command: "${command}" on path: "${workingDir}".`);
        // if (ui?.runCommand) {
        //   const uiRes = await ui.runCommand({
        //     cmd: run,
        //     workingDirectory: workingDir,
        //     shell: shell,
        //     timeout: timeout,
        //   });
        //   if (uiRes.isErr()) resolve(err(uiRes.error));
        //   resolve(ok(["", {}]));
        //   return;
        // } else {
        const outputStrings = [];
        const cp = child_process_1.exec(run, {
            shell: shell,
            cwd: workingDir,
            encoding: "utf8",
            env: Object.assign(Object.assign({}, process.env), env),
            timeout: timeout,
        }, async (error, stdout, stderr) => {
            if (error) {
                resolve(teamsfx_api_1.err(convertScriptErrorToFxError(error, resolve, run)));
            }
            else {
                // handle '::set-output' or '::set-teamsfx-env' pattern
                const outputString = outputStrings.join("");
                const outputObject = parseSetOutputCommand(outputString);
                resolve(teamsfx_api_1.ok([outputString, outputObject]));
            }
        });
        const dataHandler = (data) => {
            if (appendFile) {
                fs_extra_1.default.appendFileSync(appendFile, data);
            }
            outputStrings.push(data);
        };
        (_a = cp.stdout) === null || _a === void 0 ? void 0 : _a.on("data", (data) => {
            logProvider.info(` [script action stdout] ${maskSecretValues(data)}`);
            dataHandler(data);
        });
        (_b = cp.stderr) === null || _b === void 0 ? void 0 : _b.on("data", (data) => {
            logProvider.warning(` [script action stderr] ${maskSecretValues(data)}`);
            dataHandler(data);
        });
        // }
    });
}
exports.executeCommand = executeCommand;
function convertScriptErrorToFxError(error, resolve, run) {
    if (error.killed) {
        return new script_1.ScriptTimeoutError(run);
    }
    else {
        return new script_1.ScriptExecutionError(error.message);
    }
}
exports.convertScriptErrorToFxError = convertScriptErrorToFxError;
const SET_ENV_CMD1 = "::set-output ";
const SET_ENV_CMD2 = "::set-teamsfx-env ";
function parseSetOutputCommand(stdout) {
    const lines = stdout.toString().replace(/\r\n?/gm, "\n").split(/\r?\n/);
    const output = {};
    for (const line of lines) {
        if (line.startsWith(SET_ENV_CMD1) || line.startsWith(SET_ENV_CMD2)) {
            const str = line.startsWith(SET_ENV_CMD1)
                ? line.substring(SET_ENV_CMD1.length).trim()
                : line.substring(SET_ENV_CMD2.length).trim();
            const arr = str.split("=");
            if (arr.length === 2) {
                const key = arr[0].trim();
                const value = arr[1].trim();
                output[key] = value;
            }
        }
    }
    return output;
}
function maskSecretValues(stdout) {
    for (const key of Object.keys(process.env)) {
        if (key.startsWith("SECRET_")) {
            const value = process.env[key];
            if (value) {
                stdout = stdout.replace(value, "***");
            }
        }
    }
    return stdout;
}
exports.maskSecretValues = maskSecretValues;
function execute(command, workingDir, logger, env) {
    return new Promise((resolve, reject) => {
        // Drive letter should be uppercase, otherwise when we run webpack in exec, it fails to resolve nested dependencies.
        if (os_1.default.platform() === "win32") {
            workingDir = capitalizeFirstLetter(path.resolve(workingDir !== null && workingDir !== void 0 ? workingDir : ""));
        }
        logger === null || logger === void 0 ? void 0 : logger.info(`Start to run command: "${command}" on path: "${workingDir}".`);
        child_process_1.exec(command, { cwd: workingDir, env: Object.assign(Object.assign({}, process.env), env) }, async (error, stdout, stderr) => {
            if (error) {
                await (logger === null || logger === void 0 ? void 0 : logger.error(`Failed to run command: "${command}" on path: "${workingDir}".`));
                if (stdout) {
                    await (logger === null || logger === void 0 ? void 0 : logger.error(stdout));
                }
                if (stderr) {
                    await (logger === null || logger === void 0 ? void 0 : logger.error(stderr));
                }
                reject(error);
            }
            if (stdout) {
                await (logger === null || logger === void 0 ? void 0 : logger.debug(stdout));
            }
            resolve(stdout);
        });
    });
}
exports.execute = execute;
//# sourceMappingURL=utils.js.map