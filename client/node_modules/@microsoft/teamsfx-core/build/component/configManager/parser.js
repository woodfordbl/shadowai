"use strict";
/**
 * @author yefuwang@microsoft.com
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.yamlParser = exports.YamlParser = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const js_yaml_1 = require("js-yaml");
const ajv_1 = tslib_1.__importDefault(require("ajv"));
const globalVars_1 = require("../../core/globalVars");
const yml_1 = require("../../error/yml");
const interface_1 = require("./interface");
const lifecycle_1 = require("./lifecycle");
const path_1 = tslib_1.__importDefault(require("path"));
const folder_1 = require("../../folder");
const diagnostic_1 = require("./diagnostic");
const ajv = new ajv_1.default();
ajv.addKeyword("deprecationMessage");
const schemaPath = path_1.default.join(folder_1.getResourceFolder(), "yaml.schema.json");
const schema = fs_extra_1.default.readJSONSync(schemaPath);
const validator = ajv.compile(schema);
const schemaString = fs_extra_1.default.readFileSync(path_1.default.join(folder_1.getResourceFolder(), "yaml.schema.json"), "utf8");
const yamlDiagnostic = new diagnostic_1.YAMLDiagnostics(schemaPath, schemaString);
const environmentFolderPath = "environmentFolderPath";
const writeToEnvironmentFile = "writeToEnvironmentFile";
function parseRawProjectModel(obj) {
    const result = {};
    if (environmentFolderPath in obj) {
        if (typeof obj["environmentFolderPath"] !== "string") {
            return teamsfx_api_1.err(new yml_1.YamlFieldTypeError("environmentFolderPath", "string"));
        }
        result.environmentFolderPath = obj[environmentFolderPath];
    }
    for (const name of interface_1.LifecycleNames) {
        if (name in obj) {
            const value = obj[name];
            if (!Array.isArray(value)) {
                return teamsfx_api_1.err(new yml_1.YamlFieldTypeError(name, "array"));
            }
            for (const elem of value) {
                if (!("uses" in elem)) {
                    return teamsfx_api_1.err(new yml_1.YamlFieldMissingError(`${name}.uses`));
                }
                if (!(typeof elem["uses"] === "string")) {
                    return teamsfx_api_1.err(new yml_1.YamlFieldTypeError(`${name}.uses`, "string"));
                }
                if (!("with" in elem)) {
                    return teamsfx_api_1.err(new yml_1.YamlFieldMissingError(`${name}.with`));
                }
                if (!(typeof elem["with"] === "object")) {
                    return teamsfx_api_1.err(new yml_1.YamlFieldTypeError(`${name}.with`, "object"));
                }
                if (elem["env"]) {
                    if (typeof elem["env"] !== "object" || Array.isArray(elem["env"])) {
                        return teamsfx_api_1.err(new yml_1.YamlFieldTypeError(`${name}.env`, "object"));
                    }
                    for (const envVar in elem["env"]) {
                        if (typeof elem["env"][envVar] !== "string") {
                            return teamsfx_api_1.err(new yml_1.YamlFieldTypeError(`${name}.env.${envVar}`, "string"));
                        }
                    }
                }
                if (elem[writeToEnvironmentFile]) {
                    if (typeof elem[writeToEnvironmentFile] !== "object" ||
                        Array.isArray(elem[writeToEnvironmentFile])) {
                        return teamsfx_api_1.err(new yml_1.YamlFieldTypeError(`${name}.writeToEnvironmentFile`, "object"));
                    }
                    for (const envVar in elem[writeToEnvironmentFile]) {
                        if (typeof elem[writeToEnvironmentFile][envVar] !== "string") {
                            return teamsfx_api_1.err(new yml_1.YamlFieldTypeError(`${name}.writeToEnvironmentFile.${envVar}`, "string"));
                        }
                    }
                }
            }
            result[name] = value;
        }
    }
    return teamsfx_api_1.ok(result);
}
class YamlParser {
    async parse(path, validateSchema) {
        const raw = await this.parseRaw(path, validateSchema);
        if (raw.isErr()) {
            return teamsfx_api_1.err(raw.error);
        }
        const result = {};
        for (const name of interface_1.LifecycleNames) {
            if (name in raw.value) {
                const definitions = raw.value[name];
                if (definitions) {
                    result[name] = new lifecycle_1.Lifecycle(name, definitions);
                }
            }
        }
        if (raw.value.environmentFolderPath) {
            result.environmentFolderPath = raw.value.environmentFolderPath;
        }
        return teamsfx_api_1.ok(result);
    }
    async parseRaw(path, validateSchema) {
        let diagnostic = undefined;
        try {
            globalVars_1.globalVars.ymlFilePath = path;
            const str = await fs_extra_1.default.readFile(path, "utf8");
            diagnostic = await yamlDiagnostic.doValidation(path, str);
            const content = js_yaml_1.load(str);
            // note: typeof null === "object" typeof undefined === "undefined" in js
            if (typeof content !== "object" || Array.isArray(content) || content === null) {
                return teamsfx_api_1.err(new yml_1.InvalidYamlSchemaError(path, diagnostic));
            }
            const value = content;
            if (validateSchema) {
                const valid = validator(value);
                if (!valid) {
                    return teamsfx_api_1.err(new yml_1.InvalidYamlSchemaError(path, diagnostic));
                }
            }
            return parseRawProjectModel(value);
        }
        catch (error) {
            return teamsfx_api_1.err(new yml_1.InvalidYamlSchemaError(path, diagnostic));
        }
    }
}
exports.YamlParser = YamlParser;
exports.yamlParser = new YamlParser();
//# sourceMappingURL=parser.js.map