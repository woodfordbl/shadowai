var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setOutlookTenantReplyUrl = exports.setSharePointTenantReplyUrls = exports.setSignInAudience = exports.setIdentifierUri = exports.setApplicationSecret = exports.logoutAzure = exports.logIntoAzure = exports.isUserTenantAdmin = exports.installAzureCli = exports.isAzureCliInstalled = exports.grantAdminConsent = exports.createNewApplication = void 0;
/*
 * Copyright (c) Microsoft. All rights reserved. Licensed under the MIT license. See full license in root of repo. -->
 *
 * This file defines Azure application registration.
 */
const childProcess = require("child_process");
const defaults = require("./defaults");
const fs = require("fs");
const defaults_1 = require("./defaults");
const office_addin_usage_data_1 = require("office-addin-usage-data");
/* global require, process, console, setTimeout */
require("dotenv").config();
function createNewApplication(ssoAppName, port, userJson /* eslint-disable-line @typescript-eslint/no-unused-vars */) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            let azRestCommand = yield fs.readFileSync(defaults.azRestAppCreateCommandPath, "utf8");
            const reName = new RegExp("{SSO-AppName}", "g");
            const rePort = new RegExp("{PORT}", "g");
            azRestCommand = azRestCommand.replace(reName, ssoAppName).replace(rePort, port);
            const applicationJson = yield promiseExecuteCommand(azRestCommand, true /* returnJson */);
            if (applicationJson) {
                yield isApplicationReady(applicationJson["appId"]);
            }
            return applicationJson;
        }
        catch (err) {
            const errorMessage = `Unable to register new application: \n${err}`;
            throw new Error(errorMessage);
        }
    });
}
exports.createNewApplication = createNewApplication;
function grantAdminConsent(applicationJson) {
    return __awaiter(this, void 0, void 0, function* () {
        const azRestCommand = `az ad app permission admin-consent --id ${applicationJson["appId"]}`;
        let consented = yield waitUntil(() => tryRunAzureCommand(azRestCommand), 10, 1000);
        if (!consented) {
            const errorMessage = `Unable to set grant admin consent.  See results of each attempts`;
            throw new Error(errorMessage);
        }
        else {
            console.log("Consent granted");
        }
    });
}
exports.grantAdminConsent = grantAdminConsent;
function isAzureCliInstalled() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            let cliInstalled = false;
            switch (process.platform) {
                case "win32": {
                    const appsInstalledWindowsCommand = `powershell -ExecutionPolicy Bypass -File "${defaults.getInstalledAppsPath}"`;
                    const appsWindows = yield promiseExecuteCommand(appsInstalledWindowsCommand);
                    cliInstalled = appsWindows.filter((app) => app.DisplayName === "Microsoft Azure CLI").length > 0;
                    // Send usage data
                    defaults_1.usageDataObject.reportSuccess("isAzureCliInstalled()", {
                        cliInstalled: cliInstalled,
                    });
                    return cliInstalled;
                }
                case "darwin": {
                    const appsInstalledMacCommand = "brew list";
                    const appsMac = yield promiseExecuteCommand(appsInstalledMacCommand, false /* returnJson */);
                    cliInstalled = appsMac.toString().includes("azure-cli");
                    // Send usage data
                    defaults_1.usageDataObject.reportSuccess("isAzureCliInstalled()", {
                        cliInstalled: cliInstalled,
                    });
                    return cliInstalled;
                }
                default: {
                    const errorMessage = `Platform not supported: ${process.platform}`;
                    throw new office_addin_usage_data_1.ExpectedError(errorMessage);
                }
            }
        }
        catch (err) {
            const errorMessage = `Unable to determine if Azure CLI is installed: \n${err}`;
            throw new Error(errorMessage);
        }
    });
}
exports.isAzureCliInstalled = isAzureCliInstalled;
function installAzureCli() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            switch (process.platform) {
                case "win32": {
                    const windowsCliInstallCommand = `powershell -ExecutionPolicy Bypass -File "${defaults.azCliInstallCommandPath}"`;
                    yield promiseExecuteCommand(windowsCliInstallCommand, false /* returnJson */);
                    break;
                }
                case "darwin": {
                    // macOS
                    const macCliInstallCommand = "brew update && brew install azure-cli";
                    yield promiseExecuteCommand(macCliInstallCommand, false /* returnJson */);
                    break;
                }
                default: {
                    const errorMessage = `Platform not supported: ${process.platform}`;
                    throw new office_addin_usage_data_1.ExpectedError(errorMessage);
                }
            }
        }
        catch (err) {
            const errorMessage = `Unable to install Azure CLI: \n${err}`;
            throw new Error(errorMessage);
        }
    });
}
exports.installAzureCli = installAzureCli;
function isUserTenantAdmin(userInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            let azRestCommand = fs.readFileSync(defaults.azRestGetTenantRolesPath, "utf8");
            const tenantRoles = yield promiseExecuteCommand(azRestCommand);
            let tenantAdminId = "";
            tenantRoles["value"].forEach((item) => {
                if (item.displayName === "Global Administrator") {
                    tenantAdminId = item.id;
                }
            });
            azRestCommand = fs.readFileSync(defaults.azRestGetTenantAdminMembershipCommandPath, "utf8");
            azRestCommand = azRestCommand.replace("<TENANT-ADMIN-ID>", tenantAdminId);
            const tenantAdmins = yield promiseExecuteCommand(azRestCommand);
            let isTenantAdmin = false;
            tenantAdmins["value"].forEach((item) => {
                if (item.userPrincipalName === userInfo[0].user.name) {
                    isTenantAdmin = true;
                }
            });
            // Send usage data
            defaults_1.usageDataObject.reportSuccess("isUserTenantAdmin()", {
                isUserTenantAdmin: isTenantAdmin,
            });
            return isTenantAdmin;
        }
        catch (err) {
            const errorMessage = `Unable to determine if user is tenant admin: \n${err}`;
            throw new Error(errorMessage);
        }
    });
}
exports.isUserTenantAdmin = isUserTenantAdmin;
function logIntoAzure() {
    return __awaiter(this, void 0, void 0, function* () {
        let userJson = yield promiseExecuteCommand("az login --allow-no-subscriptions", true /* returnJson */, true /* expectError */);
        if (Object.keys(userJson).length < 1) {
            // Try alternate login
            logoutAzure();
            userJson = yield promiseExecuteCommand("az login");
        }
        return userJson;
    });
}
exports.logIntoAzure = logIntoAzure;
function logoutAzure() {
    return __awaiter(this, void 0, void 0, function* () {
        return yield promiseExecuteCommand("az logout");
    });
}
exports.logoutAzure = logoutAzure;
function promiseExecuteCommand(cmd, returnJson = true, expectError = false) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            try {
                childProcess.exec(cmd, { maxBuffer: 1024 * 102400 }, (err, stdout, stderr) => __awaiter(this, void 0, void 0, function* () {
                    if (err && !expectError) {
                        reject(stderr);
                    }
                    let results = stdout;
                    if (results !== "" && returnJson) {
                        results = JSON.parse(results);
                    }
                    resolve(results);
                }));
            }
            catch (err) {
                reject(err);
            }
        });
    });
}
function setApplicationSecret(applicationJson) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            let azRestCommand = yield fs.readFileSync(defaults.azRestAddSecretCommandPath, "utf8");
            azRestCommand = azRestCommand.replace("<App_Object_ID>", applicationJson["id"]);
            const secretJson = yield promiseExecuteCommand(azRestCommand);
            return secretJson["secretText"];
        }
        catch (err) {
            const errorMessage = `Unable to set application secret: \n${err}`;
            throw new Error(errorMessage);
        }
    });
}
exports.setApplicationSecret = setApplicationSecret;
function setIdentifierUri(applicationJson, port) {
    return __awaiter(this, void 0, void 0, function* () {
        let azRestCommand = yield fs.readFileSync(defaults.azRestSetIdentifierUriCommmandPath, "utf8");
        azRestCommand = azRestCommand
            .replace("<App_Object_ID>", applicationJson["id"])
            .replace("<App_Id>", applicationJson["appId"])
            .replace("{PORT}", port.toString());
        let identifierSet = yield waitUntil(() => tryRunAzureCommand(azRestCommand), 10, 1000);
        if (!identifierSet) {
            const errorMessage = `Unable to set identifierUri.  See results of each attempt`;
            throw new Error(errorMessage);
        }
        else {
            console.log("Itendifier Set");
        }
    });
}
exports.setIdentifierUri = setIdentifierUri;
function setSignInAudience(applicationJson) {
    return __awaiter(this, void 0, void 0, function* () {
        let azRestCommand = fs.readFileSync(defaults.azRestSetSigninAudienceCommandPath, "utf8");
        azRestCommand = azRestCommand.replace("<App_Object_ID>", applicationJson["id"]);
        let signInAudienceSet = yield waitUntil(() => tryRunAzureCommand(azRestCommand), 10, 1000);
        if (!signInAudienceSet) {
            const errorMessage = `Unable to set signInAudience.  See results of each attempt`;
            throw new Error(errorMessage);
        }
        else {
            console.log("Sign In Audience Set");
        }
    });
}
exports.setSignInAudience = setSignInAudience;
function setSharePointTenantReplyUrls(tenantName) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            let servicePrinicipalObjectlId = "";
            let setReplyUrls = true;
            const sharePointServiceId = "57fb890c-0dab-4253-a5e0-7188c88b2bb4";
            // Get tenant name and construct SharePoint SSO reply urls with tenant name
            let azRestCommand = fs.readFileSync(defaults.azRestGetOrganizationDetailsCommandPath, "utf8");
            const oneDriveReplyUrl = `https://${tenantName}-my.sharepoint.com/_forms/singlesignon.aspx`;
            const sharePointReplyUrl = `https://${tenantName}.sharepoint.com/_forms/singlesignon.aspx`;
            // Get service principals for tenant
            azRestCommand = "az ad sp list --all";
            const servicePrincipals = yield promiseExecuteCommand(azRestCommand);
            // Check if SharePoint redirects are set for SharePoint principal
            for (let item of servicePrincipals) {
                if (item.appId === sharePointServiceId) {
                    servicePrinicipalObjectlId = item.objectId;
                    if (item.replyUrls.length === 0) {
                        break;
                        // if there are reply urls set, then we need to see if the SharePoint SSO reply urls are already set
                    }
                    else {
                        for (let url of item.replyUrls) {
                            if (url === oneDriveReplyUrl || url === sharePointReplyUrl) {
                                setReplyUrls = false;
                                break;
                            }
                        }
                    }
                }
            }
            if (setReplyUrls && servicePrinicipalObjectlId) {
                azRestCommand = fs.readFileSync(defaults.azRestAddTenantReplyUrlsCommandPath, "utf8");
                const reName = new RegExp("<TENANT-NAME>", "g");
                azRestCommand = azRestCommand.replace(reName, tenantName).replace("<SP-OBJECTID>", servicePrinicipalObjectlId);
                yield promiseExecuteCommand(azRestCommand);
            }
            // Send usage data
            defaults_1.usageDataObject.reportSuccess("setTenantReplyUrls()", {
                isUserTenantAdmin: setReplyUrls,
                isServicePrincipal: !!servicePrinicipalObjectlId,
            });
            return setReplyUrls;
        }
        catch (err) {
            const errorMessage = `Unable to set tenant reply urls. \n${err}`;
            throw new Error(errorMessage);
        }
    });
}
exports.setSharePointTenantReplyUrls = setSharePointTenantReplyUrls;
function setOutlookTenantReplyUrl() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            let servicePrinicipalObjectlId = "";
            let setReplyUrls = true;
            const outlookReplyUrl = "https://outlook.office.com/owa/extSSO.aspx";
            const outlookServiceId = "bc59ab01-8403-45c6-8796-ac3ef710b3e3";
            // Get service principals for tenant
            let azRestCommand = "az ad sp list --all";
            const servicePrincipals = yield promiseExecuteCommand(azRestCommand);
            // Check if Outlook redirects are set for Outlook principal
            for (let item of servicePrincipals) {
                if (item.appId === outlookServiceId) {
                    servicePrinicipalObjectlId = item.objectId;
                    if (item.replyUrls.length === 0) {
                        break;
                        // if there are reply urls set, then we need to see if the Outlook SSO reply urls are already set
                    }
                    else {
                        for (let url of item.replyUrls) {
                            if (url === outlookReplyUrl) {
                                setReplyUrls = false;
                                break;
                            }
                        }
                    }
                }
            }
            if (setReplyUrls && servicePrinicipalObjectlId) {
                azRestCommand = fs.readFileSync(defaults.azRestAddTenantOutlookReplyUrlsCommandPath, "utf8");
                azRestCommand = azRestCommand.replace("<SP-OBJECTID>", servicePrinicipalObjectlId);
                yield promiseExecuteCommand(azRestCommand);
            }
            // Send usage data
            defaults_1.usageDataObject.reportSuccess("setOutlookTenantReplyUrls()", {
                tenantReplyUrlsSet: setReplyUrls,
                isServicePrincipal: !!servicePrinicipalObjectlId,
            });
            return setReplyUrls;
        }
        catch (err) {
            const errorMessage = `Unable to set tenant reply urls. \n${err}`;
            defaults_1.usageDataObject.reportException("setOutlookTenantReplyUrls()", errorMessage);
            throw new Error(errorMessage);
        }
    });
}
exports.setOutlookTenantReplyUrl = setOutlookTenantReplyUrl;
function waitUntil(callback, retryCount, retryDelay) {
    return __awaiter(this, void 0, void 0, function* () {
        let done = false;
        let attempts = 0;
        while (!done && attempts <= retryCount) {
            console.log(`    Attempt ${attempts + 1}`);
            yield delay(retryDelay);
            done = yield callback();
            attempts++;
        }
        return done;
    });
}
function delay(milliseconds) {
    return new Promise((resolve) => {
        setTimeout(resolve, milliseconds);
    });
}
function tryRunAzureCommand(azureCommand) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield promiseExecuteCommand(azureCommand);
            return true;
        }
        catch (err) {
            const errorMessage = `    Failed to run ${azureCommand}: \n${err}`;
            console.log(errorMessage);
            return false;
        }
    });
}
function checkIsApplicationReady(appId) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const azRestCommand = `az ad app show --id ${appId}`;
            const appJson = yield promiseExecuteCommand(azRestCommand, true /* returnJson */, true /* expectError */);
            return appJson !== "";
        }
        catch (err) {
            const errorMessage = `Unable to get application info: \n${err}`;
            throw new Error(errorMessage);
        }
    });
}
function isApplicationReady(appId) {
    return __awaiter(this, void 0, void 0, function* () {
        // Check to see if the application is available
        let appReady = false;
        let counter = 0;
        while (appReady === false && counter <= 50) {
            appReady = yield checkIsApplicationReady(appId);
            counter++;
        }
        return appReady;
    });
}
//# sourceMappingURL=configure.js.map