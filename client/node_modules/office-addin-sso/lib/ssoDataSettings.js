var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeApplicationData = exports.applicationDataConfigured = exports.getSecretFromCredentialStore = exports.addSecretToCredentialStore = void 0;
// Copyright (c) Microsoft. All rights reserved. Licensed under the MIT license. See full license in the root of the repo.
/*
    This file provides the writing and retrieval of application data
*/
const defaults = require("./defaults");
const child_process_1 = require("child_process");
const fs = require("fs");
const os = require("os");
const office_addin_manifest_1 = require("office-addin-manifest");
const office_addin_usage_data_1 = require("office-addin-usage-data");
/* global process */
function addSecretToCredentialStore(ssoAppName, secret, isTest = false, envFilePath = defaults.envDataFilePath) {
    try {
        updateEnvFileSecret(secret, envFilePath);
        switch (process.platform) {
            case "win32": {
                const addSecretToWindowsStoreCommand = `powershell -ExecutionPolicy Bypass -File "${defaults.addSecretCommandPath}" "${ssoAppName}" "${os.userInfo().username}" "${secret}"`;
                (0, child_process_1.execSync)(addSecretToWindowsStoreCommand, { stdio: "pipe" });
                break;
            }
            case "darwin": {
                // Check first to see if the secret already exists i the keychain. If it does, delete it and recreate it
                const existingSecret = getSecretFromCredentialStore(ssoAppName, isTest);
                if (existingSecret !== "") {
                    const updatSecretInMacStoreCommand = `${isTest ? "" : "sudo"} security add-generic-password -a ${os.userInfo().username} -U -s "${ssoAppName}" -w "${secret}"`;
                    (0, child_process_1.execSync)(updatSecretInMacStoreCommand, { stdio: "pipe" });
                }
                else {
                    const addSecretToMacStoreCommand = `${isTest ? "" : "sudo"} security add-generic-password -a ${os.userInfo().username} -s "${ssoAppName}" -w "${secret}"`;
                    (0, child_process_1.execSync)(addSecretToMacStoreCommand, { stdio: "pipe" });
                }
                break;
            }
            default: {
                const errorMessage = `Platform not supported: ${process.platform}`;
                throw new office_addin_usage_data_1.ExpectedError(errorMessage);
            }
        }
    }
    catch (err) {
        const errorMessage = `Unable to add secret to Credential Store: \n${err}`;
        throw new Error(errorMessage);
    }
}
exports.addSecretToCredentialStore = addSecretToCredentialStore;
function getSecretFromCredentialStore(ssoAppName, isTest = false) {
    try {
        switch (process.platform) {
            case "win32": {
                const getSecretFromWindowsStoreCommand = `powershell -ExecutionPolicy Bypass -File "${defaults.getSecretCommandPath}" "${ssoAppName}" "${os.userInfo().username}"`;
                return (0, child_process_1.execSync)(getSecretFromWindowsStoreCommand, {
                    stdio: "pipe",
                }).toString();
            }
            case "darwin": {
                const getSecretFromMacStoreCommand = `${isTest ? "" : "sudo"} security find-generic-password -a ${os.userInfo().username} -s "${ssoAppName}" -w`;
                return (0, child_process_1.execSync)(getSecretFromMacStoreCommand, {
                    stdio: "pipe",
                }).toString();
            }
            default: {
                const errorMessage = `Platform not supported: ${process.platform}`;
                throw new office_addin_usage_data_1.ExpectedError(errorMessage);
            }
        }
    }
    catch (_a) {
        return "";
    }
}
exports.getSecretFromCredentialStore = getSecretFromCredentialStore;
function envFileConfigured(envFilePath = defaults.envDataFilePath) {
    if (fs.existsSync(envFilePath)) {
        const appDataContent = fs.readFileSync(envFilePath, "utf8");
        // Check to see if the fallbackauthdialog file has already been updated and return if it has.
        return !appDataContent.includes("{CLIENT_ID}") && !appDataContent.includes("{PORT}");
    }
    else {
        return false;
    }
}
function updateEnvFile(applicationId, port, envFilePath = defaults.envDataFilePath) {
    try {
        // Update .ENV file
        if (fs.existsSync(envFilePath)) {
            const appDataContent = fs.readFileSync(envFilePath, "utf8");
            // Check to see if the fallbackauthdialog file has already been updated and return if it has.
            if (!appDataContent.includes("{CLIENT_ID}") || !appDataContent.includes("{PORT}")) {
                return false;
            }
            const updatedAppDataContent = appDataContent.replace("{CLIENT_ID}", applicationId).replace("{PORT}", port);
            fs.writeFileSync(envFilePath, updatedAppDataContent);
            return true;
        }
        else {
            throw new office_addin_usage_data_1.ExpectedError(`${envFilePath} does not exist`);
        }
    }
    catch (err) {
        const errorMessage = `Unable to write SSO application data to .env file: \n${err}`;
        throw new Error(errorMessage);
    }
}
function updateEnvFileSecret(secret, envFilePath = defaults.envDataFilePath) {
    try {
        // Update .ENV file
        if (fs.existsSync(envFilePath)) {
            const appDataContent = fs.readFileSync(envFilePath, "utf8");
            // Check to see if the fallbackauthdialog file has already been updated and return if it has.
            if (!appDataContent.includes("{CLIENT_SECRET}")) {
                return false;
            }
            const updatedAppDataContent = appDataContent.replace("{CLIENT_SECRET}", secret);
            fs.writeFileSync(envFilePath, updatedAppDataContent);
            return true;
        }
        else {
            throw new office_addin_usage_data_1.ExpectedError(`${envFilePath} does not exist`);
        }
    }
    catch (err) {
        const errorMessage = `Unable to write SSO application client secret to .env file: \n${err}`;
        throw new Error(errorMessage);
    }
}
function fallBackAuthDialogFileConfigured(isTest = false) {
    // get file contents
    let srcFileContent = "";
    if (fs.existsSync(defaults.fallbackAuthDialogTypescriptFilePath)) {
        srcFileContent = fs.readFileSync(defaults.fallbackAuthDialogTypescriptFilePath, "utf8");
    }
    else if (fs.existsSync(defaults.fallbackAuthDialogJavascriptFilePath)) {
        srcFileContent = fs.readFileSync(defaults.fallbackAuthDialogJavascriptFilePath, "utf8");
    }
    else if (isTest) {
        srcFileContent = fs.readFileSync(defaults.testFallbackAuthDialogFilePath, "utf8");
    }
    // Check to see if the fallbackauthdialog file has already been updated and return if it has.
    return !srcFileContent.includes("{PORT}");
}
function updateFallBackAuthDialogFile(applicationId, port, fallbackAuthDialogPath = defaults.fallbackAuthDialogTypescriptFilePath, isTest = false) {
    let isTypecript = false;
    try {
        // Update fallbackAuthDialog file
        let srcFileContent = "";
        if (fs.existsSync(defaults.fallbackAuthDialogTypescriptFilePath)) {
            srcFileContent = fs.readFileSync(defaults.fallbackAuthDialogTypescriptFilePath, "utf8");
            fallbackAuthDialogPath = defaults.fallbackAuthDialogTypescriptFilePath;
            isTypecript = true;
        }
        else if (fs.existsSync(defaults.fallbackAuthDialogJavascriptFilePath)) {
            srcFileContent = fs.readFileSync(defaults.fallbackAuthDialogJavascriptFilePath, "utf8");
            fallbackAuthDialogPath = defaults.fallbackAuthDialogJavascriptFilePath;
        }
        else if (isTest) {
            srcFileContent = fs.readFileSync(defaults.testFallbackAuthDialogFilePath, "utf8");
        }
        else {
            if (isTest) {
                throw new office_addin_usage_data_1.ExpectedError(`${defaults.testFallbackAuthDialogFilePath} does not exist`);
            }
            else {
                const errorMessage = `${isTypecript ? defaults.fallbackAuthDialogTypescriptFilePath : defaults.fallbackAuthDialogJavascriptFilePath} does not exist`;
                throw new Error(errorMessage);
            }
        }
        // Check to see if the fallbackauthdialog file has already been updated and return if it has.
        if (!srcFileContent.includes("{PORT}")) {
            return false;
        }
        // Update fallbackauthdialog file
        const updatedSrcFileContent = srcFileContent
            .replace("{application GUID here}", applicationId)
            .replace("{PORT}", port);
        fs.writeFileSync(fallbackAuthDialogPath, updatedSrcFileContent);
        return true;
    }
    catch (err) {
        if (isTest) {
            throw new Error(`Unable to write SSO application data to ${defaults.testFallbackAuthDialogFilePath}. \n${err}`);
        }
        else {
            const errorMessage = `Unable to write SSO application data to ${isTypecript ? defaults.fallbackAuthDialogTypescriptFilePath : defaults.fallbackAuthDialogJavascriptFilePath}. \n${err}`;
            throw new Error(errorMessage);
        }
    }
}
function projectManifestConfigured(manifestPath) {
    if (fs.existsSync(manifestPath)) {
        const manifestContent = fs.readFileSync(manifestPath, "utf8");
        // Check to see if the manifest has already been updated and return if it has
        return !manifestContent.includes("{PORT}");
    }
    else {
        return false;
    }
}
function updateProjectManifest(applicationId, port, manifestPath) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (fs.existsSync(manifestPath)) {
                // Update manifest with application guid and unique manifest id
                const manifestContent = yield fs.readFileSync(manifestPath, "utf8");
                // Check to see if the manifest has already been updated and return if it has
                if (!manifestContent.includes("{PORT}")) {
                    return false;
                }
                // Update manifest file
                const re = new RegExp("{application GUID here}", "g");
                const rePort = new RegExp("{PORT}", "g");
                const updatedManifestContent = manifestContent.replace(re, applicationId).replace(rePort, port);
                yield fs.writeFileSync(manifestPath, updatedManifestContent);
                yield office_addin_manifest_1.OfficeAddinManifest.modifyManifestFile(manifestPath, "random");
                return true;
            }
            else {
                const errorMessage = "Manifest does not exist at specified location";
                throw new office_addin_usage_data_1.ExpectedError(errorMessage);
            }
        }
        catch (err) {
            const errorMessage = `Unable to update manifest: \n${err}`;
            throw new Error(errorMessage);
        }
    });
}
function applicationDataConfigured(manifestPath = defaults.manifestFilePath, envFilePath = defaults.envDataFilePath, isTest = false) {
    const envFileUpdated = envFileConfigured(envFilePath);
    const fallbackAuthDialogFileUpdated = fallBackAuthDialogFileConfigured(isTest);
    const manifestUpdated = projectManifestConfigured(manifestPath);
    // If one of them up updated then we are partially configured and can't successfully re-configure
    return envFileUpdated || fallbackAuthDialogFileUpdated || manifestUpdated;
}
exports.applicationDataConfigured = applicationDataConfigured;
function writeApplicationData(applicationId, port, manifestPath = defaults.manifestFilePath, envFilePath = defaults.envDataFilePath, fallbackAuthDialogPath = defaults.fallbackAuthDialogTypescriptFilePath, isTest = false) {
    return __awaiter(this, void 0, void 0, function* () {
        const envFileUpdated = updateEnvFile(applicationId, port, envFilePath);
        const fallbackAuthDialogFileUpdated = updateFallBackAuthDialogFile(applicationId, port, fallbackAuthDialogPath, isTest);
        const manifestUpdated = yield updateProjectManifest(applicationId, port, manifestPath);
        return envFileUpdated && fallbackAuthDialogFileUpdated && manifestUpdated;
    });
}
exports.writeApplicationData = writeApplicationData;
//# sourceMappingURL=ssoDataSettings.js.map